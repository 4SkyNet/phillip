// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_SSBM_SSBM_H_
#define FLATBUFFERS_GENERATED_SSBM_SSBM_H_

#include "flatbuffers/flatbuffers.h"

namespace ssbm {

struct PlayerMemory;

struct GameMemory;

MANUALLY_ALIGNED_STRUCT(4) PlayerMemory FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t percent_;
  uint32_t stock_;
  uint8_t facing_;
  int8_t __padding0;
  int16_t __padding1;
  float x_;
  float y_;
  uint32_t action_;
  uint32_t action_counter_;
  uint32_t action_frame_;
  uint32_t character_;
  uint8_t invulnerable_;
  int8_t __padding2;
  int16_t __padding3;
  uint32_t hitlag_frames_left_;
  uint32_t hitstun_frames_left_;
  uint32_t jumps_left_;
  uint8_t charging_smash_;
  uint8_t on_ground_;
  int16_t __padding4;
  float speed_air_x_self_;
  float speed_ground_x_self_;
  float speed_y_self_;
  float speed_x_attack_;
  float speed_y_attack_;

 public:
  PlayerMemory(uint32_t _percent, uint32_t _stock, bool _facing, float _x, float _y, uint32_t _action, uint32_t _action_counter, uint32_t _action_frame, uint32_t _character, bool _invulnerable, uint32_t _hitlag_frames_left, uint32_t _hitstun_frames_left, uint32_t _jumps_left, bool _charging_smash, bool _on_ground, float _speed_air_x_self, float _speed_ground_x_self, float _speed_y_self, float _speed_x_attack, float _speed_y_attack)
    : percent_(flatbuffers::EndianScalar(_percent)), stock_(flatbuffers::EndianScalar(_stock)), facing_(flatbuffers::EndianScalar(static_cast<uint8_t>(_facing))), __padding0(0), __padding1(0), x_(flatbuffers::EndianScalar(_x)), y_(flatbuffers::EndianScalar(_y)), action_(flatbuffers::EndianScalar(_action)), action_counter_(flatbuffers::EndianScalar(_action_counter)), action_frame_(flatbuffers::EndianScalar(_action_frame)), character_(flatbuffers::EndianScalar(_character)), invulnerable_(flatbuffers::EndianScalar(static_cast<uint8_t>(_invulnerable))), __padding2(0), __padding3(0), hitlag_frames_left_(flatbuffers::EndianScalar(_hitlag_frames_left)), hitstun_frames_left_(flatbuffers::EndianScalar(_hitstun_frames_left)), jumps_left_(flatbuffers::EndianScalar(_jumps_left)), charging_smash_(flatbuffers::EndianScalar(static_cast<uint8_t>(_charging_smash))), on_ground_(flatbuffers::EndianScalar(static_cast<uint8_t>(_on_ground))), __padding4(0), speed_air_x_self_(flatbuffers::EndianScalar(_speed_air_x_self)), speed_ground_x_self_(flatbuffers::EndianScalar(_speed_ground_x_self)), speed_y_self_(flatbuffers::EndianScalar(_speed_y_self)), speed_x_attack_(flatbuffers::EndianScalar(_speed_x_attack)), speed_y_attack_(flatbuffers::EndianScalar(_speed_y_attack)) { (void)__padding0; (void)__padding1; (void)__padding2; (void)__padding3; (void)__padding4; }

  uint32_t percent() const { return flatbuffers::EndianScalar(percent_); }
  void mutate_percent(uint32_t _percent) { flatbuffers::WriteScalar(&percent_, _percent); }
  uint32_t stock() const { return flatbuffers::EndianScalar(stock_); }
  void mutate_stock(uint32_t _stock) { flatbuffers::WriteScalar(&stock_, _stock); }
  bool facing() const { return flatbuffers::EndianScalar(facing_) != 0; }
  void mutate_facing(bool _facing) { flatbuffers::WriteScalar(&facing_, static_cast<uint8_t>(_facing)); }
  float x() const { return flatbuffers::EndianScalar(x_); }
  void mutate_x(float _x) { flatbuffers::WriteScalar(&x_, _x); }
  float y() const { return flatbuffers::EndianScalar(y_); }
  void mutate_y(float _y) { flatbuffers::WriteScalar(&y_, _y); }
  uint32_t action() const { return flatbuffers::EndianScalar(action_); }
  void mutate_action(uint32_t _action) { flatbuffers::WriteScalar(&action_, _action); }
  uint32_t action_counter() const { return flatbuffers::EndianScalar(action_counter_); }
  void mutate_action_counter(uint32_t _action_counter) { flatbuffers::WriteScalar(&action_counter_, _action_counter); }
  uint32_t action_frame() const { return flatbuffers::EndianScalar(action_frame_); }
  void mutate_action_frame(uint32_t _action_frame) { flatbuffers::WriteScalar(&action_frame_, _action_frame); }
  uint32_t character() const { return flatbuffers::EndianScalar(character_); }
  void mutate_character(uint32_t _character) { flatbuffers::WriteScalar(&character_, _character); }
  bool invulnerable() const { return flatbuffers::EndianScalar(invulnerable_) != 0; }
  void mutate_invulnerable(bool _invulnerable) { flatbuffers::WriteScalar(&invulnerable_, static_cast<uint8_t>(_invulnerable)); }
  uint32_t hitlag_frames_left() const { return flatbuffers::EndianScalar(hitlag_frames_left_); }
  void mutate_hitlag_frames_left(uint32_t _hitlag_frames_left) { flatbuffers::WriteScalar(&hitlag_frames_left_, _hitlag_frames_left); }
  uint32_t hitstun_frames_left() const { return flatbuffers::EndianScalar(hitstun_frames_left_); }
  void mutate_hitstun_frames_left(uint32_t _hitstun_frames_left) { flatbuffers::WriteScalar(&hitstun_frames_left_, _hitstun_frames_left); }
  uint32_t jumps_left() const { return flatbuffers::EndianScalar(jumps_left_); }
  void mutate_jumps_left(uint32_t _jumps_left) { flatbuffers::WriteScalar(&jumps_left_, _jumps_left); }
  bool charging_smash() const { return flatbuffers::EndianScalar(charging_smash_) != 0; }
  void mutate_charging_smash(bool _charging_smash) { flatbuffers::WriteScalar(&charging_smash_, static_cast<uint8_t>(_charging_smash)); }
  bool on_ground() const { return flatbuffers::EndianScalar(on_ground_) != 0; }
  void mutate_on_ground(bool _on_ground) { flatbuffers::WriteScalar(&on_ground_, static_cast<uint8_t>(_on_ground)); }
  float speed_air_x_self() const { return flatbuffers::EndianScalar(speed_air_x_self_); }
  void mutate_speed_air_x_self(float _speed_air_x_self) { flatbuffers::WriteScalar(&speed_air_x_self_, _speed_air_x_self); }
  float speed_ground_x_self() const { return flatbuffers::EndianScalar(speed_ground_x_self_); }
  void mutate_speed_ground_x_self(float _speed_ground_x_self) { flatbuffers::WriteScalar(&speed_ground_x_self_, _speed_ground_x_self); }
  float speed_y_self() const { return flatbuffers::EndianScalar(speed_y_self_); }
  void mutate_speed_y_self(float _speed_y_self) { flatbuffers::WriteScalar(&speed_y_self_, _speed_y_self); }
  float speed_x_attack() const { return flatbuffers::EndianScalar(speed_x_attack_); }
  void mutate_speed_x_attack(float _speed_x_attack) { flatbuffers::WriteScalar(&speed_x_attack_, _speed_x_attack); }
  float speed_y_attack() const { return flatbuffers::EndianScalar(speed_y_attack_); }
  void mutate_speed_y_attack(float _speed_y_attack) { flatbuffers::WriteScalar(&speed_y_attack_, _speed_y_attack); }
};
STRUCT_END(PlayerMemory, 76);

MANUALLY_ALIGNED_STRUCT(4) GameMemory FLATBUFFERS_FINAL_CLASS {
 private:
  PlayerMemory player_one_;
  PlayerMemory player_two_;
  float player_two_pointer_x_;
  float player_two_pointer_y_;
  uint32_t frame_;
  uint32_t menu_state_;
  uint32_t stage_;

 public:
  GameMemory(const PlayerMemory &_player_one, const PlayerMemory &_player_two, float _player_two_pointer_x, float _player_two_pointer_y, uint32_t _frame, uint32_t _menu_state, uint32_t _stage)
    : player_one_(_player_one), player_two_(_player_two), player_two_pointer_x_(flatbuffers::EndianScalar(_player_two_pointer_x)), player_two_pointer_y_(flatbuffers::EndianScalar(_player_two_pointer_y)), frame_(flatbuffers::EndianScalar(_frame)), menu_state_(flatbuffers::EndianScalar(_menu_state)), stage_(flatbuffers::EndianScalar(_stage)) { }

  const PlayerMemory &player_one() const { return player_one_; }
  PlayerMemory &mutable_player_one() { return player_one_; }
  const PlayerMemory &player_two() const { return player_two_; }
  PlayerMemory &mutable_player_two() { return player_two_; }
  float player_two_pointer_x() const { return flatbuffers::EndianScalar(player_two_pointer_x_); }
  void mutate_player_two_pointer_x(float _player_two_pointer_x) { flatbuffers::WriteScalar(&player_two_pointer_x_, _player_two_pointer_x); }
  float player_two_pointer_y() const { return flatbuffers::EndianScalar(player_two_pointer_y_); }
  void mutate_player_two_pointer_y(float _player_two_pointer_y) { flatbuffers::WriteScalar(&player_two_pointer_y_, _player_two_pointer_y); }
  uint32_t frame() const { return flatbuffers::EndianScalar(frame_); }
  void mutate_frame(uint32_t _frame) { flatbuffers::WriteScalar(&frame_, _frame); }
  uint32_t menu_state() const { return flatbuffers::EndianScalar(menu_state_); }
  void mutate_menu_state(uint32_t _menu_state) { flatbuffers::WriteScalar(&menu_state_, _menu_state); }
  uint32_t stage() const { return flatbuffers::EndianScalar(stage_); }
  void mutate_stage(uint32_t _stage) { flatbuffers::WriteScalar(&stage_, _stage); }
};
STRUCT_END(GameMemory, 172);

}  // namespace ssbm

#endif  // FLATBUFFERS_GENERATED_SSBM_SSBM_H_
