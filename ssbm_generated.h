// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_SSBM_SSBM_H_
#define FLATBUFFERS_GENERATED_SSBM_SSBM_H_

#include "flatbuffers/flatbuffers.h"

namespace ssbm {

struct PlayerMemory;

struct GameMemory;

struct ControllerState;

MANUALLY_ALIGNED_STRUCT(4) PlayerMemory FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t percent_;
  uint32_t stock_;
  uint8_t facing_;
  int8_t __padding0;
  int16_t __padding1;
  float x_;
  float y_;
  uint32_t action_;
  uint32_t action_counter_;
  uint32_t action_frame_;
  uint32_t character_;
  uint8_t invulnerable_;
  int8_t __padding2;
  int16_t __padding3;
  uint32_t hitlag_frames_left_;
  uint32_t hitstun_frames_left_;
  uint32_t jumps_left_;
  uint8_t charging_smash_;
  uint8_t on_ground_;
  int16_t __padding4;
  float speed_air_x_self_;
  float speed_ground_x_self_;
  float speed_y_self_;
  float speed_x_attack_;
  float speed_y_attack_;

 public:
  PlayerMemory(uint32_t _percent, uint32_t _stock, bool _facing, float _x, float _y, uint32_t _action, uint32_t _action_counter, uint32_t _action_frame, uint32_t _character, bool _invulnerable, uint32_t _hitlag_frames_left, uint32_t _hitstun_frames_left, uint32_t _jumps_left, bool _charging_smash, bool _on_ground, float _speed_air_x_self, float _speed_ground_x_self, float _speed_y_self, float _speed_x_attack, float _speed_y_attack)
    : percent_(flatbuffers::EndianScalar(_percent)), stock_(flatbuffers::EndianScalar(_stock)), facing_(flatbuffers::EndianScalar(static_cast<uint8_t>(_facing))), __padding0(0), __padding1(0), x_(flatbuffers::EndianScalar(_x)), y_(flatbuffers::EndianScalar(_y)), action_(flatbuffers::EndianScalar(_action)), action_counter_(flatbuffers::EndianScalar(_action_counter)), action_frame_(flatbuffers::EndianScalar(_action_frame)), character_(flatbuffers::EndianScalar(_character)), invulnerable_(flatbuffers::EndianScalar(static_cast<uint8_t>(_invulnerable))), __padding2(0), __padding3(0), hitlag_frames_left_(flatbuffers::EndianScalar(_hitlag_frames_left)), hitstun_frames_left_(flatbuffers::EndianScalar(_hitstun_frames_left)), jumps_left_(flatbuffers::EndianScalar(_jumps_left)), charging_smash_(flatbuffers::EndianScalar(static_cast<uint8_t>(_charging_smash))), on_ground_(flatbuffers::EndianScalar(static_cast<uint8_t>(_on_ground))), __padding4(0), speed_air_x_self_(flatbuffers::EndianScalar(_speed_air_x_self)), speed_ground_x_self_(flatbuffers::EndianScalar(_speed_ground_x_self)), speed_y_self_(flatbuffers::EndianScalar(_speed_y_self)), speed_x_attack_(flatbuffers::EndianScalar(_speed_x_attack)), speed_y_attack_(flatbuffers::EndianScalar(_speed_y_attack)) { (void)__padding0; (void)__padding1; (void)__padding2; (void)__padding3; (void)__padding4; }

  uint32_t percent() const { return flatbuffers::EndianScalar(percent_); }
  void mutate_percent(uint32_t _percent) { flatbuffers::WriteScalar(&percent_, _percent); }
  uint32_t stock() const { return flatbuffers::EndianScalar(stock_); }
  void mutate_stock(uint32_t _stock) { flatbuffers::WriteScalar(&stock_, _stock); }
  bool facing() const { return flatbuffers::EndianScalar(facing_) != 0; }
  void mutate_facing(bool _facing) { flatbuffers::WriteScalar(&facing_, static_cast<uint8_t>(_facing)); }
  float x() const { return flatbuffers::EndianScalar(x_); }
  void mutate_x(float _x) { flatbuffers::WriteScalar(&x_, _x); }
  float y() const { return flatbuffers::EndianScalar(y_); }
  void mutate_y(float _y) { flatbuffers::WriteScalar(&y_, _y); }
  uint32_t action() const { return flatbuffers::EndianScalar(action_); }
  void mutate_action(uint32_t _action) { flatbuffers::WriteScalar(&action_, _action); }
  uint32_t action_counter() const { return flatbuffers::EndianScalar(action_counter_); }
  void mutate_action_counter(uint32_t _action_counter) { flatbuffers::WriteScalar(&action_counter_, _action_counter); }
  uint32_t action_frame() const { return flatbuffers::EndianScalar(action_frame_); }
  void mutate_action_frame(uint32_t _action_frame) { flatbuffers::WriteScalar(&action_frame_, _action_frame); }
  uint32_t character() const { return flatbuffers::EndianScalar(character_); }
  void mutate_character(uint32_t _character) { flatbuffers::WriteScalar(&character_, _character); }
  bool invulnerable() const { return flatbuffers::EndianScalar(invulnerable_) != 0; }
  void mutate_invulnerable(bool _invulnerable) { flatbuffers::WriteScalar(&invulnerable_, static_cast<uint8_t>(_invulnerable)); }
  uint32_t hitlag_frames_left() const { return flatbuffers::EndianScalar(hitlag_frames_left_); }
  void mutate_hitlag_frames_left(uint32_t _hitlag_frames_left) { flatbuffers::WriteScalar(&hitlag_frames_left_, _hitlag_frames_left); }
  uint32_t hitstun_frames_left() const { return flatbuffers::EndianScalar(hitstun_frames_left_); }
  void mutate_hitstun_frames_left(uint32_t _hitstun_frames_left) { flatbuffers::WriteScalar(&hitstun_frames_left_, _hitstun_frames_left); }
  uint32_t jumps_left() const { return flatbuffers::EndianScalar(jumps_left_); }
  void mutate_jumps_left(uint32_t _jumps_left) { flatbuffers::WriteScalar(&jumps_left_, _jumps_left); }
  bool charging_smash() const { return flatbuffers::EndianScalar(charging_smash_) != 0; }
  void mutate_charging_smash(bool _charging_smash) { flatbuffers::WriteScalar(&charging_smash_, static_cast<uint8_t>(_charging_smash)); }
  bool on_ground() const { return flatbuffers::EndianScalar(on_ground_) != 0; }
  void mutate_on_ground(bool _on_ground) { flatbuffers::WriteScalar(&on_ground_, static_cast<uint8_t>(_on_ground)); }
  float speed_air_x_self() const { return flatbuffers::EndianScalar(speed_air_x_self_); }
  void mutate_speed_air_x_self(float _speed_air_x_self) { flatbuffers::WriteScalar(&speed_air_x_self_, _speed_air_x_self); }
  float speed_ground_x_self() const { return flatbuffers::EndianScalar(speed_ground_x_self_); }
  void mutate_speed_ground_x_self(float _speed_ground_x_self) { flatbuffers::WriteScalar(&speed_ground_x_self_, _speed_ground_x_self); }
  float speed_y_self() const { return flatbuffers::EndianScalar(speed_y_self_); }
  void mutate_speed_y_self(float _speed_y_self) { flatbuffers::WriteScalar(&speed_y_self_, _speed_y_self); }
  float speed_x_attack() const { return flatbuffers::EndianScalar(speed_x_attack_); }
  void mutate_speed_x_attack(float _speed_x_attack) { flatbuffers::WriteScalar(&speed_x_attack_, _speed_x_attack); }
  float speed_y_attack() const { return flatbuffers::EndianScalar(speed_y_attack_); }
  void mutate_speed_y_attack(float _speed_y_attack) { flatbuffers::WriteScalar(&speed_y_attack_, _speed_y_attack); }
};
STRUCT_END(PlayerMemory, 76);

MANUALLY_ALIGNED_STRUCT(4) GameMemory FLATBUFFERS_FINAL_CLASS {
 private:
  PlayerMemory player_one_;
  PlayerMemory player_two_;
  float player_two_pointer_x_;
  float player_two_pointer_y_;
  uint32_t frame_;
  uint32_t menu_state_;
  uint32_t stage_;

 public:
  GameMemory(const PlayerMemory &_player_one, const PlayerMemory &_player_two, float _player_two_pointer_x, float _player_two_pointer_y, uint32_t _frame, uint32_t _menu_state, uint32_t _stage)
    : player_one_(_player_one), player_two_(_player_two), player_two_pointer_x_(flatbuffers::EndianScalar(_player_two_pointer_x)), player_two_pointer_y_(flatbuffers::EndianScalar(_player_two_pointer_y)), frame_(flatbuffers::EndianScalar(_frame)), menu_state_(flatbuffers::EndianScalar(_menu_state)), stage_(flatbuffers::EndianScalar(_stage)) { }

  const PlayerMemory &player_one() const { return player_one_; }
  PlayerMemory &mutable_player_one() { return player_one_; }
  const PlayerMemory &player_two() const { return player_two_; }
  PlayerMemory &mutable_player_two() { return player_two_; }
  float player_two_pointer_x() const { return flatbuffers::EndianScalar(player_two_pointer_x_); }
  void mutate_player_two_pointer_x(float _player_two_pointer_x) { flatbuffers::WriteScalar(&player_two_pointer_x_, _player_two_pointer_x); }
  float player_two_pointer_y() const { return flatbuffers::EndianScalar(player_two_pointer_y_); }
  void mutate_player_two_pointer_y(float _player_two_pointer_y) { flatbuffers::WriteScalar(&player_two_pointer_y_, _player_two_pointer_y); }
  uint32_t frame() const { return flatbuffers::EndianScalar(frame_); }
  void mutate_frame(uint32_t _frame) { flatbuffers::WriteScalar(&frame_, _frame); }
  uint32_t menu_state() const { return flatbuffers::EndianScalar(menu_state_); }
  void mutate_menu_state(uint32_t _menu_state) { flatbuffers::WriteScalar(&menu_state_, _menu_state); }
  uint32_t stage() const { return flatbuffers::EndianScalar(stage_); }
  void mutate_stage(uint32_t _stage) { flatbuffers::WriteScalar(&stage_, _stage); }
};
STRUCT_END(GameMemory, 172);

MANUALLY_ALIGNED_STRUCT(4) ControllerState FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t buttonA_;
  uint8_t buttonB_;
  uint8_t buttonX_;
  uint8_t buttonY_;
  uint8_t buttonL_;
  uint8_t buttonR_;
  int16_t __padding0;
  float analogL_;
  float analogR_;
  float mainX_;
  float mainY_;
  float cX_;
  float cY_;

 public:
  ControllerState(bool _buttonA, bool _buttonB, bool _buttonX, bool _buttonY, bool _buttonL, bool _buttonR, float _analogL, float _analogR, float _mainX, float _mainY, float _cX, float _cY)
    : buttonA_(flatbuffers::EndianScalar(static_cast<uint8_t>(_buttonA))), buttonB_(flatbuffers::EndianScalar(static_cast<uint8_t>(_buttonB))), buttonX_(flatbuffers::EndianScalar(static_cast<uint8_t>(_buttonX))), buttonY_(flatbuffers::EndianScalar(static_cast<uint8_t>(_buttonY))), buttonL_(flatbuffers::EndianScalar(static_cast<uint8_t>(_buttonL))), buttonR_(flatbuffers::EndianScalar(static_cast<uint8_t>(_buttonR))), __padding0(0), analogL_(flatbuffers::EndianScalar(_analogL)), analogR_(flatbuffers::EndianScalar(_analogR)), mainX_(flatbuffers::EndianScalar(_mainX)), mainY_(flatbuffers::EndianScalar(_mainY)), cX_(flatbuffers::EndianScalar(_cX)), cY_(flatbuffers::EndianScalar(_cY)) { (void)__padding0; }

  bool buttonA() const { return flatbuffers::EndianScalar(buttonA_) != 0; }
  void mutate_buttonA(bool _buttonA) { flatbuffers::WriteScalar(&buttonA_, static_cast<uint8_t>(_buttonA)); }
  bool buttonB() const { return flatbuffers::EndianScalar(buttonB_) != 0; }
  void mutate_buttonB(bool _buttonB) { flatbuffers::WriteScalar(&buttonB_, static_cast<uint8_t>(_buttonB)); }
  bool buttonX() const { return flatbuffers::EndianScalar(buttonX_) != 0; }
  void mutate_buttonX(bool _buttonX) { flatbuffers::WriteScalar(&buttonX_, static_cast<uint8_t>(_buttonX)); }
  bool buttonY() const { return flatbuffers::EndianScalar(buttonY_) != 0; }
  void mutate_buttonY(bool _buttonY) { flatbuffers::WriteScalar(&buttonY_, static_cast<uint8_t>(_buttonY)); }
  bool buttonL() const { return flatbuffers::EndianScalar(buttonL_) != 0; }
  void mutate_buttonL(bool _buttonL) { flatbuffers::WriteScalar(&buttonL_, static_cast<uint8_t>(_buttonL)); }
  bool buttonR() const { return flatbuffers::EndianScalar(buttonR_) != 0; }
  void mutate_buttonR(bool _buttonR) { flatbuffers::WriteScalar(&buttonR_, static_cast<uint8_t>(_buttonR)); }
  float analogL() const { return flatbuffers::EndianScalar(analogL_); }
  void mutate_analogL(float _analogL) { flatbuffers::WriteScalar(&analogL_, _analogL); }
  float analogR() const { return flatbuffers::EndianScalar(analogR_); }
  void mutate_analogR(float _analogR) { flatbuffers::WriteScalar(&analogR_, _analogR); }
  float mainX() const { return flatbuffers::EndianScalar(mainX_); }
  void mutate_mainX(float _mainX) { flatbuffers::WriteScalar(&mainX_, _mainX); }
  float mainY() const { return flatbuffers::EndianScalar(mainY_); }
  void mutate_mainY(float _mainY) { flatbuffers::WriteScalar(&mainY_, _mainY); }
  float cX() const { return flatbuffers::EndianScalar(cX_); }
  void mutate_cX(float _cX) { flatbuffers::WriteScalar(&cX_, _cX); }
  float cY() const { return flatbuffers::EndianScalar(cY_); }
  void mutate_cY(float _cY) { flatbuffers::WriteScalar(&cY_, _cY); }
};
STRUCT_END(ControllerState, 32);

}  // namespace ssbm

#endif  // FLATBUFFERS_GENERATED_SSBM_SSBM_H_
